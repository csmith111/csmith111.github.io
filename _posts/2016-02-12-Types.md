---
layout: post
title:  "Functional Reactive Programing with Elm: Part VI -  Types"
date:   2016-02-12 13:00:28 -0500
summary:  In this post we will look at the role played by different Types in Elm. Most of this should be familiar to someone with a functional programming background like Haskell, but the syntax and some details are slightly different.
categories: jekyll update
---
In this section we will look at the role played by Types in Elm.

* Statically typed systems: Languages like C, Java and C# are examples of languages that fall in this category. They are characterized by the fact that the types of all variables have to be declared/known at compile time when the type checking is done.

* Dynamically typed systems: Languages like Python and Ruby are examples of languages that fall in this category. They are characterized by the fact that the types of all variables change depending on what is assigned to them. In other words types are associated with values not variables. These languages typically do most of their type checking at run time.

* Type Inference : is when the compiler can infer the types of variables and automatically assign them to variables. In case the user has declared the type this information is used to verify the assignment. Type checking like static languages is done at compile time. This approach tries to keep the benefits of static typing while allowing the programmer to not "have to" declare the types all the time.

The subject of type systems is vast and we cannot do justice to the subject here so I have only highlighted a couple of interesting features. You can begin a long journey of understanding and analyzing [Type Systems here.][Type Systems]
It is tempting to think that we have the best situation when we  languages that [support static typing where possible and dynamic typing where needed][Types discussion].

Elm as we shall see is a statically typed language with support for type inference.

Here we can see a list of

### Basic Types

Let us create an instance of each of the Basic types:

{% highlight Haskell %}
import Graphics.Element exposing (..)

aInt : Int
aInt = 10

aFloat : Float
aFloat = 2.0

aString : String
aString= "Hi"

aChar : Char
aChar = 'c'

aBool : Bool
aBool = True


main = flow down [
           print "The value of aInt is : " (aInt)
          ,print "The value of aFloat is : " (aFloat)
          ,print "The value of aString is : " (aString)
          ,print "The value of aChar is : " (aFloat)
          ,print "The value of aBool is : " (aFloat)
         ]

--a helper function to make display easier
print message value = show (message ++ (toString value))

{% endhighlight %}

You can just enter this code in the [online editor/runner.][try-elm]

### Type Classes - Number

I will not get into a discussion on Typeclasses as the creators of Elm wanted to suppress so of the complexity of more advanced usage of types. (You will have to refer to my Haskell notes to see a description of this.)
Anyway, `number` (is essentially a built-in type class in Elm, there are a few more like this) and represents a type that supports addition, subtraction, etc. I did not manage to find a lot of documentation on this so this is based on my experimentation.


{% highlight Haskell %}
import Graphics.Element exposing (..)

aInt :Int
aInt =3

aFloat : Float
aFloat = 3.0

triple : number -> number
triple number =
  3*number

main = flow down [
            print "The value of triple aInt is : " (triple aInt)
           ,print "The value of triple aFloat is : " (triple aFloat)
          ]

--a helper function to make display easier
print message value = show (message ++ (toString value))
{% endhighlight %}

So what is see above is a simple use of the `number` type. The function triple is declare to have type `triple : number -> number`. So that means this function will accept any type that supports operations like +, - etc. (or more precisely is an instance of the number typeclass.)

Okay, that is about all the detail we will go into here on typeclasses but at least you get a sense of how to use it, and a flavor of what it means.

### Type Aliases

Type aliases are not a mechanism by which you can give more relevant type names to built in types. Here are a couple of examples:

{% highlight Haskell %}
import Graphics.Element exposing (..)

type alias Name = String
type alias Id = Int

aName : names
aName = "Jim"

aId : Id
aId = 10001

main = flow down [
            print "The value of aName is : " (aName)
           ,print "The value of aId is : " (aId)
          ]
--a helper function to make display easier
print message value = show (message ++ (toString value))

{% endhighlight %}

### Records

Even though functional programming is all about programming with functions, we still need to work/operate on data.
This is where records come in.

For example let us consider we want to work with data for an Employee which we take to contain an `id : Int , firstName : String, lastName : String`. We can use a record to represent this data. While it takes a little time designing good records to represent your data will make your programs easier to understand and maintain.

{% highlight Haskell %}
import Graphics.Element exposing (..)

-- creating a record
aEmployee = {id = 101 , firstName = "Michael", lastName = "Jordan"}

-- accessing the fields
fName = aEmployee.firstName
lName = aEmployee.lastName

-- field accessors
fName1 = List.map .firstName [aEmployee, {id = 101 , firstName = "Michael", lastName = "Jordan"}]   

-- update fields  of a Record (Notice we did not mutate the id so it is copied over)
aNewEmployee = {aEmployee | firstName = "Magic", lastName = "Johnson" }  

 -- type aliases for records
type alias Employee = {id : Int, firstName : String, lastName : String}

anotherEmployee : Employee
anotherEmployee = {id=103, firstName = "Larry", lastName = "Bird" }

main = flow down [
             print "The value of aEmployee is : " (aEmployee)
            ,print "The value of aNewEmployee is : " (aNewEmployee)
            ,print "The value of anotherEmployee is : " (anotherEmployee)

          ]
--a helper function to make display easier
print message value = show (message ++ (toString value))
{% endhighlight %}

Records are a lightweight data structure similar to a tuple in that it can hold a fixed number of different types. Unlike tuples the elements of a record have names and accessors that allow us to work with the data stored in a record. You can work without type aliases for a record, but if you are going to create multiple instances of the record, then it is more compact and less error prone to create the type alias.

It is important to keep in mind some of the distinctions between Objects and Records, there is a great [description of this here, along with more information on records.] [ObjectsAndRecords]

[ObjectsAndRecords]:http://elm-lang.org/docs/records

### Enumerations

Often we need to describe fixed sets of values in our programs.
For example we can describe the state of a program as `{NotStarted, Running, Completed}`. Of course we could represent this as a set of integers, but Enumerations are a much nicer way to do this.
We then use the Enumerations typically as switches to control the logic we use to handle these different cases.

{% highlight Haskell %}
import Graphics.Element exposing (..)

type Status = NotStarted|Running|Completed|Crashed

log : Status -> String
log status =
 case status of
   NotStarted -> "The program is not started"
   Running -> "The program is Running"
   Completed -> "The program is Completed"
   Crashed -> "The program has Crashed"


main = flow down [
             print "Program Status: " (log NotStarted)
            ,print "Program Status: " (log Running)
            ,print "Program Status: " (log Completed)
            ,print "Program Status: " (log Crashed)
          ]
--a helper function to make display easier
print message value = show (message ++ (value))
{% endhighlight %}

In this case we have just implement simple function that converts the different Status cases to strings. But you could write similar functions to trigger different functions based on  the Status enumeration.

{% highlight Haskell %}
import Graphics.Element exposing (..)

type Direction = Left|Right|Up|Down

type alias Point = { x : Float, y : Float}

movePoint : Point -> Direction -> Point
movePoint aPoint aDirection =
     case aDirection of
      Left -> {aPoint | x = aPoint.x - 1}
      Right -> {aPoint | x = aPoint.x + 1}
      Up -> {aPoint | y = aPoint.y + 1}
      Down -> {aPoint | y = aPoint.y - 1}

p : Point
p = {x=0, y=0}   

main = flow down [
             print "The starting point p : " (movePoint p Up)
            ,print "P moved Up gives : " (movePoint p Up)
            ,print "p moved Down gives" (movePoint p Down)
          ]
--a helper function to make display easier
print message value = show (message ++ (toString value))
{% endhighlight %}

### Algebraic Types

Algebraic types allow us to create types that consist of other types. A record is also a composite type, but it contains/requires all the the types that go into its definition.  
__Union Types__ - __OR__ Types:

Let us look at an example arising in a graphics situation.
Consider three objects Points, Circles and Squares.






### Recursive Types

### Pattern Matching on Types

 * Records
 {% highlight Haskell %}
 type alias Point =
   { x : Float
   , y : Float
   }

 hypotenuse : Point -> Float
 hypotenuse {x,y} =
   sqrt (x^2 + y^2)
 {% endhighlight %}

### Lists And Tuples


### Generics

Now we come to an extremely powerful concept, consider a function


[Type Systems]:https://en.wikipedia.org/wiki/Type_system
[Type Inference]:[https://en.wikipedia.org/wiki/Type_inference]
[Types discussion]:http://lambda-the-ultimate.org/node/834
[try-elm]: http://elm-lang.org/try
