---
layout: post
title:  "Functional Reactive Programing with Elm: Part IV - Elm Signals"
date:   2016-02-10 13:00:28 -0500
summary:  In this post we will look how Elm enables us to build functional reactive programs.
categories: jekyll update
---

Reactive programs requires us to write programs that react to a stream of "events". Additionally, making these programs composable allows us to use all our functional programming techniques to manipulate makes these programs - **Functional Reactive Programming (FRP)**.

The first concept that is needs is how do we represent a stream of events? Just like `List a` represent an extensible structure containing elements of type a, we introduce `Signal a` which contains an extensible structure which contains the type a.

**In some sense (actually rather precise sense) there is a relationship/duality between extensible structures (Lists) in space (memory) and Signals (Stream of events) that are extensible structures in time.**

**A Signal is a special type that represents a set of values changing over time** `type Signal a`.The coordinates representing the location on the mouse (Mouse.position) and the keys pressed on the keyboard are examples of Signals. Our programs include a networks of such signals that we process by:

* Map
   - `map : (a -> b) -> Signal a -> Signal b`
* Merge
  - `merge : Signal a -> Signal a -> Signal a`
* Fold Over/ Manage state:
  - `foldp : (a -> s -> s) -> s -> Signal a -> Signal s`
* Filter
  - `filter : (a -> Bool) -> a -> Signal a -> Signal a`

Understanding how to use all these functions and getting familiar with some of the standard Signals like the mouse position (`Mouse.position : Signal (Int, Int)`)  and keyboard presses (`Keyboard.presses : Signal KeyCode`)etc should take us a long way to a clear understanding of **FRP**.

If you have not already done this please take a look at the [great article on Signals on elm-lang][Signals-elm-lang].

{% highlight Haskell %}
import Graphics.Element exposing (..)
import Mouse

main : Signal Element
main =
  Signal.map show Mouse.position

{% endhighlight %}

You can just enter this code in the [online editor/runner.][try-elm]

So let us see if we can understand this code. Mouse.position is a Signal that contains a tuple of Integers which are the mouse coordinates, we want to `show` each of these tuples.
Just like we can use the function map for lists:
`map : (a -> b) -> List a -> List b`, the Signal module defines a map function that maps a function over a Signal: `map : (a -> b) -> Signal a -> Signal b`.
 Okay so that is all we need to do map show over the Mouse position Signal using Signal.map! (Amazing how close the code is to this description in text.)

Now let us look at how we can write a simple function that operates on two values  and map it over two streams.

{% highlight Haskell %}
import Mouse
import Signal exposing (map2)
import Graphics.Element exposing (Element, show)

combine x y = show (x, y)

main : Signal Element
main =
  map2 combine Mouse.x Mouse.y

{% endhighlight %}

This should give you a clear picture of how we can take normal functions like `combine` that we can define and **lift/map** them over Signals.

[Signals-elm-lang]:http://elm-lang.org/guide/reactivity#signals
